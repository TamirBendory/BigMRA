

\documentclass[english, onecolumn]{IEEEtran}

\pdfoutput=1

\usepackage[T1]{fontenc}
\usepackage[latin9]{inputenc}
\usepackage{verbatim}
\usepackage{float}
\usepackage{amsthm}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{graphicx}
%\usepackage{multirow}
\usepackage{color}
\usepackage{url}
\usepackage{authblk}
\usepackage{xr}

\newcommand{\TODO}[1]{{\color{red}{[#1]}}}

\makeatletter

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% LyX specific LaTeX commands.
%% Because html converters don't know tabularnewline
\providecommand{\tabularnewline}{\\}
\floatstyle{ruled}
\newfloat{algorithm}{tbp}{loa}
\providecommand{\algorithmname}{Algorithm}
\floatname{algorithm}{\protect\algorithmname}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Textclass specific LaTeX commands.
\numberwithin{equation}{section}
\numberwithin{figure}{section}
\theoremstyle{plain}
\newtheorem{thm}{\protect\theoremname}[section]
\theoremstyle{definition}
\newtheorem{defn}[thm]{\protect\definitionname}
\theoremstyle{remark}
\newtheorem{claim}[thm]{\protect\claimname}
\theoremstyle{plain}
\newtheorem{lem}[thm]{\protect\lemmaname}

\newtheorem*{lem*}{Lemma}

\theoremstyle{remark}
\newtheorem{rem}[thm]{\protect\remarkname}
\theoremstyle{plain}
\newtheorem{corollary}[thm]{\protect\corollaryname}
\theoremstyle{plain}
\newtheorem{proposition}[thm]{\protect\propositionname}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% User specified LaTeX commands.
%\usepackage{slashbox}

  
\usepackage{babel}
\providecommand{\claimname}{Claim}
\providecommand{\definitionname}{Definition}
\providecommand{\lemmaname}{Lemma}
\providecommand{\remarkname}{Remark}
\providecommand{\theoremname}{Theorem}
\providecommand{\corollaryname}{Corollary}
\providecommand{\propositionname}{Proposition}


\newcommand{\reals}{\mathbb{R}}
\newcommand{\RL}{\mathbb{R}^L}
\newcommand{\CL}{\mathbb{C}^L}
\newcommand{\RNN}{\mathbb{R}^{N\times N}}
\newcommand{\CNN}{\mathbb{C}^{N\times N}}
\newcommand{\inner}[2]{\left\langle {#1}, {#2} \right\rangle}
\newcommand{\E}[1]{\mathbb{E}\left\{ {#1} \right\}} 




\begin{document}

%\begin{frontmatter}


\title{Blind deconvolution from multiple instances}

 \author{Tamir Bendory}

\maketitle

We aim to recover a signal $x$ from a set of its convolutions with unknown kernels 
\begin{equation}
y_i = x \ast h_i,
\end{equation}
or, equivalently,
\begin{equation}
\hat{y}_i[k] = \hat{x}[k]  \hat{h}_i[k],
\end{equation}

Suppose we are given $N$ measurements. Then, averaging over them yields:
\begin{equation}
\frac{1}{N}\sum_{i=1}^N\hat{y}_i[k] = \hat{x}[k]  \frac{1}{N}\sum_{i=1}^N \hat{h}_i[k].
\end{equation} 
When $N\to \infty$ then 
\begin{equation}
\E{\hat{y}[k]} = \hat{x}[k]   \E{\hat{h}[k]}.
\end{equation} 
So, if $ \E{{h}}$ is known and invertible, then we can estimate $y$. Without loss of generality, we assume that $\vert\hat{x}[k]\vert=1 $. 

If we have no access to  $\E{\hat{h}[k]}$, we go to the second-order matrix. Here, we get 
\begin{equation}
y_iy_i^T = C_xh_ih_i^TC_x^T.
\end{equation}
Or, 
\begin{equation}
\E{yy^T} = C_x\E{hh^T}C_x^T.
\end{equation}
Under the assumption $h$ is i.i.d.\, then this is an eigenvalue problem.




%\bibliographystyle{ieeetr}
%\bibliography{ref}


\end{document}


